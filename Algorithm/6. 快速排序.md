# 6. 快速排序

Tags: Algorithm

[TOC]

## 6.0 介绍

快速排序是一种特殊的归并排序，它基于分治策略，
将数组分成左和右两部分，然后将他们分别独立排序。

> **数组的切分是很关键的**
快速排序和归并排序的唯一不同就是，它要求在左右排序完成后，数组**就已经有序**了。 

## 6.1 基本实现

```java
public class Quick {
    public static void sort (Comparable[] a) {
        // Disable the dependency to the input String
        // It's very important.
        StdRandom.shuffle(a);
        sort(a, 0, a.lenth - 1);
    }
    
    private static void sort (Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int j = partition(a, lo, hi);
        // Sort the left subarray.
        sort(a, lo, j - 1);
        // Sort the right subarray.
        sort(a, j + 1, hi);
    }
}
```

> 可以看到，和归并排序一样，快速排序中真正做比较和交换的，实际上是**切分**这一个过程，而不是 `sort()` 方法

## 6.2 切分

切分的目标是找到一个元素：
1. 它的左边的所有元素都不大于它
2. 它的右边的所有元素都不小于它

一般来说，我们并不能找到这样的元素，所以我们进行以下的操作：

1. 随机的选择元素
2. 从数组的两端同时开始扫描数组
3. 如果元素不在正确的位置，那么就交换它
    
    > 当 $a[i]$ 大于 $v$ 或者 $a[j]$ 小于 $v$ 的时候，交换 $a[i]$ 和 $a[j]$
    
4. 直到这两个指针相遇，然后将切分元素放到相遇位置。

![The Partition](http://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png)

### 6.2.1 实现

```java
private static int partition(Comparable[] a, int lo, int hi) {
    int i = lo, j = hi + 1;     // The scanner
    Comparable v = a[lo];
    while (true) {
        /**
        * Scan the left and ritht, and exchange
        */
        // Check for the a[i] is less than the v
        while (less(a[++i], v)) {
            if (i == hi) {
                break;
            }
        }
        // Check the a[j] is larger than the v
        while (less(v, a[--j])) {
             if (j == lo) {     // Redundant, because the v is the lo
                break;
             } 
        }
        if (i >= j) {
            break;
        }
        
        // if all were checked, then exchange the a[i] and a[j]
        exch(a, i, j);
    }
    
    // Place the v into the a[j] place
    exch(a, lo, j);
    return j;
}
```

### 6.2.2 注意事项

1. 切分**在原本的数组**中发生

    > 我们并不采用辅助数组来进行切分，这样会导致数组空间的浪费，同时将数组复制的时间消耗可能无法忽视
    
2. 不要越界
3. 注意保持随机性

    > 在快速排序中保持随机性是保证此算法性能的关键
    
4. 注意循环的终止条件

    >　一个程序员常犯的错误就是没有考虑到数组可能包含与切分你元素的值相同的元素，从而导致了循环无法结束
    
5. 注意递归的终止条件

    > 如果你不能把切分元素放入到正确的位置（放入到了错误的位置），那么就有可能引起一个无法终止的递归，这是要极力避免的。
    
## 6.3 性能

快速排序需要 $\sim 2NlnN$ 次的比较和 $1/6$ 的交换
在最坏情况下，快速排序需要 $N^2 / 2$ 次的比较

**但是通过打乱输入保证随机性可以防止这种情况的发生**

## 6.4 改进

### 6.4.1 切换到插入排序

对于一些小型数组，插入排序会比快速排序要快，这是由于快速排序使用了递归方法进行排序

```java
if (hi <= lo) return;
//Just replace the statement as
if (ho <= lo + M) {
    Insertion.sort(a, lo, hi); 
    return;
}
// Usually the M value is system-related, but within 5 to 15 is considerable.
```

### 6.4.2 三取样切分

快速排序基于切分，如果切分元素选择的好，那么就可以减少切分所用的时间，从而提高算法性能
在实践中，我们一般使用**三取样**，然后取其**中位数**的形式来选取切分元素

### 6.4.3 三向切分的快速排序

对于有大量重复性元素的数组，我们采用这个算法

使用 3 个指针来维护数组的 3 个部分，小于切分元素的，等于切分元素的，大于切分元素的
    
> - 指针$lt$ 使得 $a[lo...lt - 1]$ 都比 $v$ 小
- 指针 $gt$ 使得 $a[gt + 1... hi]$ 都比 $v$ 大
- 指针 $i$ 使得 $a[lt...i - 1]$ 都等于 $v$

步骤：
1. 当 $a[\ i\ ]$ 小于 $v$ 时，交换 $a[\ lt\ ]$ 和 $a[\ i\ ]$， 然后 $lt$ 和 $v$ 加一
2. 当 $a[\ i\ ]$ 大于 $v$ 时，交换 $a[\ gt\ ]$ 和 $a[\ i\ ]$， 然后 $gt$ 减一
3. 当 $a[\ i\ ]$ 等于 $v$ 时，将 $i$ 加一[^footnote6]

[^footnote6]:每一个操作都会保证数组元素不变，然后减少 $gt-1$ 的值，只有这样，循环才会结束

#### 6.4.3.1 实现

```java
public class Quick3way {
    private static void sort(Comparable a, int lo, int hi) {
        if (hi <= lo) return;
        int lt = lo, i = lo + 1, gt = hi;
        Comararble v = a[lo];
        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if (cmp < 0) {
                exch(a, lt++, i++);
            }
            else if (cmp >0) {
                exch(a, i, gt--);
            }
            else {
                i++;
            }
        }
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}
```

![3way Quick Sort](http://algs4.cs.princeton.edu/23quicksort/images/partitioning3-overview.png)

#### 6.3.2 性能

对于含有重复元素的数组，我们有一个值来描述这个数组的信息含量，它叫做**香农信息量($H$)**

$$H = -(p_1lgp_1 + p2lgp_2 + \cdots + p_klgp_k)$$

$H - The \ Shannon\ information$
$p_i - The\ posibillty\ of\ the\ ith\ key\ was\ selected$

对于含有重复元素的数组，不存在任何基于比较的排序算法能够保证在 $NH - N$ 次比较之中将 $N$ 个元素排序。其中 $H$ 是由主键值概率定义的香农信息量

所以，它证明了三向切分的快速排序是最好的基于比较的算法，**信息量最优**





