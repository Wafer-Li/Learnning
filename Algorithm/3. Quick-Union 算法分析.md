
# 3. Quick-Union 算法分析
Tags: Algorithm

---

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:0 updateOnSave:1 -->

[3. Quick-Union 算法分析](#3-quick-union-算法分析)  
&emsp;[3.1 概念](#31-概念)  
&emsp;[3.2 Union-Find 的实现](#32-union-find-的实现)  
&emsp;[3.3 `union()` 和 `find()` 的实现](#33-union-和-find-的实现)  
&emsp;&emsp;[3.3.1 Quick-Find 算法](#331-quick-find-算法)  
&emsp;&emsp;[3.3.2 Quick-Union 算法](#332-quick-union-算法)  
&emsp;&emsp;&emsp;[3.3.2.1 基本概念](#3321-基本概念)  
&emsp;&emsp;&emsp;[3.3.2.2 实现](#3322-实现)  
&emsp;&emsp;&emsp;[3.3.3.4 性能](#3334-性能)  
&emsp;&emsp;[3.3.3 加权的 Quick-Union 算法](#333-加权的-quick-union-算法)  
&emsp;&emsp;&emsp;[3.3.3.1 实现](#3331-实现)  
&emsp;&emsp;&emsp;[3.3.3.2 性能](#3332-性能)  
&emsp;&emsp;[3.3.4 路径压缩的 Quick-Union 算法](#334-路径压缩的-quick-union-算法)  
&emsp;&emsp;&emsp;[3.3.4.1 实现](#3341-实现)  
&emsp;&emsp;&emsp;[3.3.4.2 性能](#3342-性能)  
&emsp;&emsp;[3.3.5 比较](#335-比较)  

<!-- /MDTOC -->

---

Quick-Union 算法是用于判断互联网中我们是否需要新建立一条连接来使整个网络连通。即，元素的连通性问题。

## 3.1 概念

- 连接

	连接是一种等价关系，它意味着以下特点：

	- 自反性：$p$ 连接着 $p$
	- 对称性：如果 $p$ 和 $q$ 相连，那么 $q$ 与 $p$ 相连
	- 传递性：如果 $p$ 与 $q$ 相连，$q$ 与 $r$ 相连，那么 $p$ 与 $r$ 相连

## 3.2 Union-Find 的实现

```java
public static void main(String[] args) {
    int N = StdIn.readInt();    //read the Number of CONTACTS
    UF UF = new UF(N);          //Initialize the data structure

    while(!StdIn.isEmpty()) {
        int p = StdIn.readInt();
        int q = StdIn.readInt();

        if(uf.connected(p,q)) {
            //If it is connected, ignore it
            continue;
        }

        uf.uinon(p,q);          //Merge the contacts
        StdOut.println(p + " " + q);
    }
}
```

## 3.3 `union()` 和 `find()` 的实现

基于 `id[]` 数组，他们的每一个索引都是一个节点

### 3.3.1 Quick-Find 算法

这个版本需要 $(N + 3)(N - 1) \sim N^2$ 次数组访问

```java
public int find (int p) {
    return id[p];
}

public void union(int p, int q) {
    // Merge p and q into the same component
    int pID = find(p);
    int qID = find(q);

    // If the p and q are at the same component,
    // do nothing and return.
    if(pID = qID) {
        retrun;
    }

    // Rename the p component to the q component
    for(int i = 0; i< id.lenth; i++) {
        if(id[i] == pID) {
            id[i] = qID;
        }
    }
    count --;   // Decrease the component counter
}
```

### 3.3.2 Quick-Union 算法

使用**树**作为基本结构以避免每次调用 `union()` 时，都要扫描**整个数组**

#### 3.3.2.1 基本概念

1. 使用树作为基本的数据结构
2. 每一个节点的 `id[]` 元素就是**另一个节点的名字**，我们认为它们之间建立了一个**连接**

    > 例如， $p$ 和 $q$ 是两个节点，如果 $p$ 和 $q$ 连接，那么 `id[p] == q`

3. 如果 `id[p] == p`，那么我们称 $p$ 是一个根节点

#### 3.3.2.2 实现

```java
private int find(int p) {
    // Find the root of the contact's component
    while (p != id[p]) {
        p = id[p];
    }
    return p;
}

public void union(int p, int q) {
    // Merge the root contact of the p's component and the q's component
    int pRoot = find(p);
    int qRoot = find(q);

    // If the two components' root are the same, return.
    if (pRoot == qRoot) {
        return;
    }

    // Set the p's tree links with q's tree.
    // Now, the qRoot is the father contact of the qRoot.
    id[pRoot] = qRoot;

    count --;
}
```

#### 3.3.3.4 性能

虽然一般来说，Quick-Union 算法比 Quick-Find 算法要快，但是在最坏情况下，Quick-Union 算法仍然需要 $2(1 + 2 + \dots + N) \sim N^2$ 次的数组访问

> 原因在于， `union()` 方法是**随机的连接两棵树**，就有可能将**大树连接到小树上**，增加树的深度。
如果所有的树都是大树连接到小树上，那么树就变成了线性表，此时即为最坏情况。

### 3.3.3 加权的 Quick-Union 算法

我们通过给树增加权值，从而可以避免上面的随机连接的情况。
权值即为树的大小。

#### 3.3.3.1 实现

```java
public class WeightedQuickUnionUF {

    /**
    * We need a new array to count the tree's size
    * The index is the root contact
    * The value is the corresponding size of the tree

    * Baically, we use the root contact to stand for the tree
    */
    private int[] sz;
    ....
    public WeightedQuickUnionUF (int N) {
        ...
        sz = new int[N];
        for (int i = 0; i < N; i++) {
            // Initialize the sz[] as 1.
            // No one was linked at the first.
            sz[i] = 1;
        }
    }
    ...
    public int find(int p) {
        // Find the root contact
        while (p != id[p]) {
            p = id[p];
        }
        retrun p;
    }

    public void union(int p, int q) {
        ...
        if (sz[i] < sz[j]) {    // Link the smaller tree's root contact to the bigger one
            id[i] = j;
            sz[j] += sz[i];     // Adding the weight(or size) of the component
        }
        else {
            id[j] = i;
            sz[i] += sz[j];
        }
    }
}
```

#### 3.3.3.2 性能

通过使用加权算法，构造的森林中，任意节点的深度最多为 $logN$ [^footnote4]

[^footnote4]: 在算法中 $logN$ 和 $log_2{N}$ 等价


### 3.3.4 路径压缩的 Quick-Union 算法

更进一步，我们可以在遍历到一个节点的时候，就和它的根节点连在一起，
由于我们**只检查连通分量（即根节点）是否相连**，所以上述做法在 **Union-Find** 问题中是没有副作用的，同时可以**极大地减少树的深度**，从而提升算法性能。

#### 3.3.4.1 实现

```java
public int find(int p) {
    int pParent = p;

    // Find the p's root
    while(pParent != id[pParent]) {
        pParent = id[pParent];
    }
    // Now, the pParent equals to the pRoot

    /**
    * Notice:
    * When run the find() method,
    * They will link all the contacts of this component to the root
    */
    while (id[p] != p) {
        p = id[p];  // Move p to its parent
        id[p] = pParent;    // The id[p] is still p's prarent, now link it to the root
    }

    return pParent;
}
```

#### 3.3.4.2 性能

这个算法的性能是一个 $arc$ 函数，**十分接近常数**。

### 3.3.5 比较

![The comparation of the Union-Find algorithm](http://algs4.cs.princeton.edu/15uf/images/uf-performance.png)
