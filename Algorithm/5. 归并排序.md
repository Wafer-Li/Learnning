# 5. 归并排序

Tags:Algorithm

---

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:0 updateOnSave:1 -->

[5. 归并排序](#5-归并排序)  
&emsp;[5.0 介绍](#50-介绍)  
&emsp;[5.1 实现](#51-实现)  
&emsp;[5.2 自顶向下的归并排序](#52-自顶向下的归并排序)  
&emsp;&emsp;[5.2.1 实现](#521-实现)  
&emsp;&emsp;[5.2.2 性能](#522-性能)  
&emsp;[5.3 自底向上的归并排序](#53-自底向上的归并排序)  
&emsp;&emsp;[5.3.1 实现](#531-实现)  
&emsp;&emsp;[5.3.2 性能](#532-性能)  
&emsp;[5.4 比较](#54-比较)  
&emsp;[5.5 展望](#55-展望)  

<!-- /MDTOC -->

---

## 5.0 介绍

归并排序是一种递归算法；
其主要思想是**分而治之**策略，通过将一个大数组分成一个个小数组，通过递归地分割，最后归并成一个有序的数组。

需要注意的是，**比较是在归并的过程中实行的**。

## 5.1 实现

```java
public static void merge(Comparable[] a, int lo, int mid, int hi) {
    // Merge the a[lo...mid] and the a[mid... hi]

    int i = lo, j = mid + 1;

    // Copy the a[lo...hi] to the assistant array
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k];
    }

    // Merge
    // During the merge, do the comparition
    for (int k = lo; k <= hi; k++) {
        if (i > mid) {                  // When the left side was empty
            a[k] = aux[j++];
        }
        else if (j > hi) {              // When the right side was empty
                                        // Notice that the j is the middle index
                                        // it could also be the lo and gradually reduce
            a[k] = aux[i++];
        }
        else if (less(aux[j], aux[i])) { // Either, compare the left side and the right side
            a[k] = axu[j++];
        }
        else {
            a[k] = aux[i++];
        }
    }
}
```

## 5.2 自顶向下的归并排序

它的思想是将数据集合分割，然后递归调用 sort 和 merge 来完成排序

### 5.2.1 实现

```java
public class Merge {

    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.lenth];
        sort(a, 0, a.lenth - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;

        sort(a, lo, mid);       // Sort the left side
        sort(a, mid + 1, hi);   // Sort the right side

        merge(a, lo, mid, hi);  // Merge the result
    }
}
```

> 注意，只有 merge 方法才真正进行了排序， sort 方法仅仅是分割数组

### 5.2.2 性能

对于自顶向下的归并排序，需要 ${1 \over 2} NlogN \sim NlogN$ 次比较和 $6NlogN$ 次数组访问

## 5.3 自底向上的归并排序

它的主要思想是通过不断归并小数组，从而得到一个有序的大数组。
注意与其不同的是，自顶向下是将整个数组分为**左右半边分别处理**，
而这里的方法是将**整个数组都打散为小数组**之后再行合并。

### 5.3.1 实现

```java
public class  MergeBU {
    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        int N = a.lenth;
        aux = new Comparable[N];

        for (int sz = 1; sz < N; sz = sz + sz) {
            for (int lo = 0; lo < N - sz; lo + = sz + sz) {
                merge (a, log, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
            }
        }
    }
}
```

> 注意这里使用了循环的版本，而不是递归的版本

### 5.3.2 性能

对于一个长度为 N 的数组，自底向上的归并排序需要 ${1 \over 2} NlogN \sim NlogN$ 次比较和最多 $6NlogN$ 次的数组访问


## 5.4 比较

1. 当数组长度为 2 的幂的时候，这两个方法需要的开支是相同的

    > 它们的时间复杂度的增长级别是相同的，数组访问的增长级别也是相同的

2. 自底向上的归并排序适合于使用**链表**作为数据结构的数据，由于它只需要**调整数组链接**即可，而不需要去创建新的链表节点

3. 由于自底向上使用的是循环算法，一般来说都要比使用递归算法的自顶向下的归并排序要快



## 5.5 展望

归并排序是**基于比较的排序算法**中**渐进最优**的


> 归并排序**确保了** 即使在最坏情况，所需要的最少比较次数都是 $\sim NlogN$。
由于没有一个基于比较的排序算法能**保证**所需要的最少次数都比 $log(N!)$ 要少，由于 $log(N!) \sim NlogN$，所以归并排序是**渐进最优**的**基于比较的**排序算法

> 基于比较的排序可以由**决策树**来描述。
树的高度 $h$ 即为所需要进行的比较次数，由排列原理可知，$N$ 个元素有 $N!$ 中排序方式，一个决策树的叶子个数必须要能容纳下 $N!$ 中排序结果，**否则将无法完成排序**。
因为如果不能容纳下所有的结果，一旦输入改变，那么得出的排序结果就可能是错误的。
所以一棵比较算法的决策树，**至少**有 $N!$ 个叶节点，而高为 $h$ 的树具有最多叶节点个数为 $2^h$，则有：
$$
2^h \ge leaves \ge N! \\
\Rightarrow \ h \ \ge \ lg(N!) \sim NlogN
$$
