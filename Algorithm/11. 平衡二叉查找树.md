# 11. 平衡二叉查找树

Tags: Algorithm

---

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:0 updateOnSave:1 -->

[11. 平衡二叉查找树](#11-平衡二叉查找树)  
&emsp;[11.1 2-3 Tree](#111-2-3-tree)  
&emsp;&emsp;[11.1.1 搜索](#1111-搜索)  
&emsp;&emsp;[11.1.2 插入](#1112-插入)  
&emsp;&emsp;&emsp;[11.1.2.1 在 2-节点 中插入](#11121-在-2-节点-中插入)  
&emsp;&emsp;&emsp;[11.1.2.2 在只有 3-节点的树中插入](#11122-在只有-3-节点的树中插入)  
&emsp;&emsp;&emsp;[11.1.2.3 在父节点为 2-节点 的 23-节点 插入](#11123-在父节点为-2-节点-的-23-节点-插入)  
&emsp;&emsp;&emsp;[11.1.2.4 在父节点为 3-节点 的 3-节点 插入](#11124-在父节点为-3-节点-的-3-节点-插入)  
&emsp;&emsp;[11.1.3 性能](#1113-性能)  
&emsp;&emsp;[11.1.4 结论](#1114-结论)  
&emsp;[11.2 红黑树](#112-红黑树)  
&emsp;&emsp;[11.2.1 新的节点定义](#1121-新的节点定义)  
&emsp;&emsp;[11.2.2 变形](#1122-变形)  
&emsp;&emsp;&emsp;[11.2.2.1 旋转](#11221-旋转)  
&emsp;&emsp;&emsp;&emsp;[11.2.2.1.1 向左旋转](#112211-向左旋转)  
&emsp;&emsp;&emsp;&emsp;[11.2.2.1.2 向右旋转](#112212-向右旋转)  
&emsp;&emsp;&emsp;[11.2.2.2 颜色转换](#11222-颜色转换)  
&emsp;&emsp;[11.2.3 插入](#1123-插入)  

<!-- /MDTOC -->

---

## 11.1 2-3 Tree

2-3 树是一种拥有 2 种不同节点的树，称为 2-节点 和 3-节点

1. 2-节点，拥有**一个键值**和**两个链接**（左子树和右子树），实际上就是普通的二叉搜索树节点
2. 3-节点，拥有**两个键值**和**三个链接**，左子结点比最小的键值小，右子结点比最大的键值大，中子节点介于两者之间

![2-3 Tree](http://algs4.cs.princeton.edu/33balanced/images/23tree-anatomy.png)

### 11.1.1 搜索

2-3 树的搜索和 BST 一样，根据比较结果来进入子树进行搜索。

### 11.1.2 插入

2-3 树的插入稍微有些复杂，我们分情况来讨论。


#### 11.1.2.1 在 2-节点 中插入

这是最简单的一种情况，只需**将 2-节点 变为 3-节点**即可。

![Insert 2-node](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png)

#### 11.1.2.2 在只有 3-节点的树中插入

在这种情况下，我们可以构建一个暂时的 4-节点，然后将其**分裂**为**三个 2-节点**。

这个操作会增加树的高度

![Insert only 3-node](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png)

#### 11.1.2.3 在父节点为 2-节点 的 23-节点 插入

这种情况就更加复杂了，此时，我们**将 3-节点 变为临时的 4-节点，然后将其分裂。**

> 在这种情况下，分裂会将生成的父节点移动到上一层去

![Insert 3-node with the 2-node father](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png)

#### 11.1.2.4 在父节点为 3-节点 的 3-节点 插入

这种情况和上一个稍微有点像，我们只需要将 3-节点 替换为临时的 4-节点，然后**将其分裂**。此时**父节点成为 4-节点**，所以我们**递归地**进行分裂操作，直到到达根节点位置。

**如果根节点仍然是 4-节点，那么我们就将根节点分裂，增加树的高度。**

![Insert into 3-node with 3-node father and reach root](http://algs4.cs.princeton.edu/33balanced/images/23tree-split.png)

### 11.1.3 性能

2-3 树能保证任何的相关操作均在 $lgN$ 级别

> 在一个 $N$ 个节点的 2-3 树，搜索和插入只需要访问不超过 $lgN$ 个节点。

### 11.1.4 结论

2-3 树能保证树在插入时的**完美 2-节点 平衡**，不会出现 BST 的最坏情况。

然而，2-3 树十分难以实现，在实际工程中，我们需要对代码尽量小的改动，从而达到性能优化的结果。
显然 2-3 树并不能满足这个需求

## 11.2 红黑树

红黑树是 2-3 树的一种简易实现方式，它拥有两种链接，红链接和黑链接。

黑链接是普通的二叉查找树链接，红链接表示了一个 3-节点

![Red Black Tree](http://algs4.cs.princeton.edu/33balanced/images/redblack-encoding.png)

在这里，我们使用的是**左斜的红黑树**，它满足以下条件：

1. 红链接永远在左边（向左倾斜）
2. 一个节点不能同时链接两个红链接
3. 红黑树是**完美黑链接平衡的**

需要注意的是，如果红黑树满足以上条件，那么其和 2-3 树就是等价的。
事实上，如果把红链接画平，那么红黑树就是一个 2-3 树。

### 11.2.1 新的节点定义

为了表示链接的颜色，我们需要定义一个新的节点，或者说向原有节点增加新的属性——颜色。

```java
pravite class Node {
    Key key;
    Value val;
    int N;
    boolean color;
}
```
> 在这里，我们为原有的节点增加一个布尔值来表示**指向它的链接的颜色**，这样定义能省去一些麻烦，具体在下面的内容中会讨论到。

### 11.2.2 变形

当我们往红黑树插入节点时，需要进行一些**变形**来让红黑树满足以上条件，就像我们对 2-3 树插入节点时做的处理一样。

#### 11.2.2.1 旋转

第一个重要的变形是**旋转变形**。
当我们在插入节点的时候，不可避免的会破坏红黑树的条件，有时会出现**红色的右链接**，或者**两个连续的红链接**等。
对于这些情况，我们需要对红黑树做适当的旋转变换来让它重新满足红黑树的条件。

##### 11.2.2.1.1 向左旋转

![Rotate Left](http://algs4.cs.princeton.edu/33balanced/images/redblack-left-rotate.png)

> 由图可以注意到，所谓的**旋转**主要做了两件事：

> 1. 交换根节点
2. 将中间子树调换父亲

> 剩下就是转换颜色，修改子树节点数目等。
抓住这个根本操作，就不会出错。

```java
Node rotateLeft(Node h) {
    Node x = h.right;
    h.right = x.left;   // Link the middle
    x.left = h;         // x ship to the root
    x.color = h.color;  // Change color
    h.color = RED;      // Change color
    x.N = h.N;          // Ship amount

    // Calculate the amount of left subtree
    h.N = 1 + size(h.left) + size(h.right);

    return x;           // Return new root
}
```

> 注意，我们采用了和二叉查找树一样的**递归返回引用**的方法，这样有利于重用原有代码和维护树的链接性。

##### 11.2.2.1.2 向右旋转

这个方法和向左旋转大同小异，核心的思想就是转换根节点和中间子树。

关于必要性：有些时候遇到复杂的红链接情况，就首先要将连接向右旋转，随后在进行其他变形操作。

虽然红黑树条件中不允许红色右链接的存在使得此方法显得无意义，但是此方法的用意在于**构建一个便于处理的中间状态**。

![Rotate Right](http://algs4.cs.princeton.edu/33balanced/images/redblack-right-rotate.png)

#### 11.2.2.2 颜色转换

当我们在进行旋转的过程中，很可能会遇到**两个子节点的链接都是红色**的情况。

由于红链接代表了 3-节点，显然 2 个红链接就代表了一个 4-节点，在 2-3 树插入中，我们需要将临时的 4-节点 **分裂**，在红黑树中就是第二种变形——颜色转换。

步骤如下：

1. 将两个红链接变成黑链接
2. 将父节点的链接颜色变为**红色**


![Flip Colors](http://algs4.cs.princeton.edu/33balanced/images/color-flip.png)

```java
void filpColors(Node h) {
    h.color = RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}
```

> 这很好地体现了 4-节点 的分裂过程。
首先，我们将红链接变为黑色，事实上增加了两个新节点，也就是将 4-节点 **分裂了**
其次，将父节点的链接变为**红色**，此时父节点就会变为上层 3-节点 的一部分，也满足了在分裂过程中，**将中间节点向上传递**的思想。

> 假如父节点是根节点时，由于**没有任何链接指向根节点，所以根节点的颜色变得无关紧要了**
这也是为什么我们在定义新节点的时候要将其颜色定义为**指向其链接的颜色**的原因

### 11.2.3 插入

最后，我们终于进入了真正的插入环节，根据 2-3 树的插入思想，红黑树的插入步骤如下：

1. 新节点的颜色是**红色的**

    > 由于 2-3 树在插入之后一定会形成至少一个 3-节点（有时还会有临时的 4-节点）

2. 如果右子结点是红色，左子结点是黑色，那么向左旋转

    > 右子结点为红色，左子结点为黑色，说明红黑树中存在红色的右链接，将其向左旋转

3. 如果左子结点和它的左子结点都是红色的，那么向右旋转

    > 这种情况说明红黑树中**存在两个连续的红色链接**，说明存在一个内部的 4-节点，此时我们**将其向右旋转**，变为可以进行颜色转换的状态，随后通过颜色转换来将 4-节点 分裂

4. 如果左子结点和右子结点都是**红色的**，那么进行**颜色转换**

    > 此时说明存在 4-节点，通过颜色转换将其分裂

```java
public void put(Key key, Value val) {
    root = put(root, key, val);
    root.color = BLACK;
}

private Node put(Node h, Key key, Value val) {
    if (h == null) {
        return new Node(key, val, 1, RED);
    }
    int cmp = key.compareTo(h.key);
    if (cmp < 0) h.left = put(h.left, key, val);
    else if (cmp > 0) h.right = put(h.right, key, val);
    else h.val = val;

    if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);
    if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left) && isRed(h.right)) flipColors(h);

    h.N = size(h.left) + size(h.right) + 1;
    return h;
}
```

> 需要注意的是，有可能存在**需要多次变换**的情况，所以上述检测需要**依次进行一遍**

>> 比如**折线式的红链接（红色的左链接 + 红色的右链接）**，此时就需要先将右链接向左旋转，变为**连续的红链接**，再将上面的链接进行右旋转，变为**两个红色的子链接**，随后进行颜色转换。

> 同时，为了能让父节点也能进行正确的变形，**变形操作要放置在递归方法之后**，也就是修改值之后再进行变形操作。
