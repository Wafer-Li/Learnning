
<center>北京邮电大学软件学院</center>
========

### <center>2015-2016 学年第二学期实验报告</center>



实验目的
========

通过实现并优化自己的内存分配器，练习内存分配相关的数据结构和算法。使用
`mmap` 申请虚拟内存，通过 `LD_PRELOAD` 在运行时替换系统库的调用。实现 C
的标准内存申请 API（`malloc, calloc, realloc, free`）。

实验环境
========

Arch Linux：

linux 4.5.4

glibc 2.23

make 4.1

gcc 6.1.1

gdb 7.11

实验内容
========

（整个项目和报告的源文件可以在
https://github.com/hghwng/toy-heap-manager 下载）

综述
----

使用基于 BiBOP 的分配策略：根据申请的记录大小，将分配请求分为两大类。

-   当记录大于 1024 字节时，分配独立的页。

-   当记录小于 1024
    字节时，将记录放置于包（bag）内。包存储着多个记录，还要维护包信息的元数据。一个包占用一整个页。包之间通过链表维护：

    -   尚有剩余空间的包置于空链表中。若记录插入后，包不再有剩余空间，则移入满链表。若记录释放后，包内不再有有效记录时，释放整个包的空间。

    -   已经存满数据的包置于满链表中。当有记录被释放时，移动当前包进入空链表。

    以 \\([2^i+1, 2^{i+1}], 3 \le i \le 10\\)
    将记录分类，将记录插入对应的包内。这样，可以确保任意时刻对每个包内记录空间的使用率不低于
    50%。

数据结构
--------

### 包头

首先设计包的结构，并以 `bucket_header` 命名。

对于大记录（BLOB）类型的数据，需要记录当前申请了多少页，在释放或重分配时会用到。对于小记录（bucket）类型的数据，需要放置双向环形链表节点，用来维护空包链表；需要存储当前的记录，在插入新记录时会用到。使用
`type` 域记录当前包的类型，并设置魔术值区分 BLOB 和 bucket：

<!-- more -->### 链表

使用链表节点和有效数据分离的思路，双向环形链表的数据结构，通过宏实现基本的链表操作。

不同于一般的节点数据耦合的思路，遍历链表时，需要从给定的结构体成员的链表节点地址，恢复结构体本身的基地址。方法很简单，将结构体成员的地址直接减去结构体成员的偏移量即可。ANSI
C 中提供了 `offsetof` 宏，使用 0
指针来获得节点相较于结构体的偏移量，不再赘述。

### Bitmap

通过 bitmap
维护记录的存在性，每八个记录只需要一个字节，节省空间。在这里使用 64 bit
作为 bitmap 的基本单元（block）。

除了基本的接口外，本项目需要高效地寻找可用记录，即在 bitmap
中获得某个被置位的比特的位置；还需要统计记录的使用情况，即在 bitmap
中对已置位的比特计数。

使用 glibc 提供的内置函数 `__builtin_popcount` 和 `__builtin_ctz`
可以在各个平台高效地进行比特计数和尾部 0
位置的寻找。结合基本单元的特种，使用 64 bit
的版本。注意到这两个方法对于开头的 0 不敏感，可以将末尾的非 64
整数倍的比特一并处理。

初始化和内存申请
----------------

在全局变量中存储 `/dev/zero`
的文件描述符和各个类型包的链表头。在动态库被载入时，需要初始化这些数据。依据
GCC 的文档，使用 `__attribute__` 将 `init` 函数置入 `.init_array`
段，由链接器在程序初始化时调用。

使用 `mmap` 和 `munmap` 模拟对页的申请和释放：

大包管理
--------

为了提高内存访问效率，在一些平台下避免错误，需要对齐地址为处理器字长的整数倍。在目前测试的
x86\_64 平台下，以 8 做对齐。

注意到内存分配器在存储用户记录外，还要存储包头及对齐带来的空隙。以此计算需要的字节数并换算成页数。其余地方比较简单，不再赘述。

小包管理
--------

### 计算

由于小包根据记录大小分为不同的类别，所以不同类别的小包能存放的记录数是不同的。在分配空间时必须计算。

刨去上面提到的包头大小及对齐空隙，剩下的内容用来存放记录。每个记录实质上由
\\(2^i\\) 字节的用户数据空间和 1 比特（即 0.125 字节）的可用状态 bitmap
组成。

在分配内存时，跳过包头和可变长度的 bitmap
才是用户数据区。在此区间进一步计算，可用获得当前记录所在用户数据区的偏移量。

在释放内存时，需要通过用户记录地址还原包头地址，以及当前记录在包中的位置。结合内存布局，仔细计算。计算过程比较繁琐，且涉及一定的
C 语言技巧，不再赘述。

<!-- more -->### 记录申请

先分组。对于小于最小记录长度的，设置为最小记录长度。其余部分需要注意的是，一类包的适用空间是在
\\([2^i+1, 2^{i+1}]\\)，在统计最高位位置时需要减去
1。直接计算最高位所在位置即可。确定分组后，要确保当前分组的存在空包。没有空包则需要申请。在获取空包后，通过
bitmap
的辅助，查找可用空记录在包中的位置。计算过程比较繁琐，不再赘述。最后，当空包变满后，需要移动当前包所在链表。

释放包的过程类似，设置 bitmap 后，检查状态。0
记录的包需要释放，否则移动进入空表链表。

外部接口
--------

对函数名称不进行 `static`
修饰，获得导出的符号，以便后期覆盖系统库的符号。

各类外部接口都需要对 `NULL` 地址和 0 长度的申请做特殊处理。

`malloc` 根据申请长度选择合适的包类型即可。

`calloc` 类似于 `malloc`，但需要注意 `calloc` 将申请的空间全部置零。

`realloc` 先检查是否可以于原地重分配；若不可以，则调用 malloc
申请内存并拷贝，最后释放原始内存。

`free` 根据不同的包分类释放。

实验结果
========

编写 Makefile，构建项目。

    src git:(master) % make                                                          22:27
    cc -c -g -Wall -Wextra -fPIC -DDEBUG=0 heap.c -o bin/heap.o
    cc -shared -g bin/heap.o -o bin/libheap.so

    src git:(master) % make run                                                      22:27
    LD_PRELOAD=bin/libheap.so /bin/ls
    bin  bitmap.h  heap.c  heap.h  list.h  Makefile


    src git:(master) % make run APP='/bin/find .'                                    22:27
    LD_PRELOAD=bin/libheap.so /bin/find .
    .
    ./bin
    ./bin/heap.o
    ./bin/libheap.so
    ./bitmap.h
    ./heap.c
    ./heap.h
    ./list.h
    ./Makefile
    ./.heap.c.swp
    ./.heap.h.swp
    ./.list.h.swp
    ./.bitmap.h.swp

进行较高强度的测试。在覆盖系统库符号的情况下，调用 `/bin/find /`
枚举全盘文件，调用 `/bin/bash` 执行脚本，均未见执行异常。

小结
====

调试指针，调到泪奔！调位运算，忘记吃饭！
