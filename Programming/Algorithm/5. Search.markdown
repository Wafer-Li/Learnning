# 5. Search

Tags: Algorithm

[TOC]

---

## 1) The symbol table

> The symbol table is a table which contains a pair of the key and the value.

> The table consist of the **Insertion** and the **Deletion**

### 0. Designs

1. Table do not allow the repeated keys.
> That's the key-value pair is uniqe, one key correspond to only one value.

2. Table do not allow `null` key and `null` value
> The `null` key will cause an Runtime Exception.
Not allowing the `null` value can let us use much less API to acomplish more operations.
> 
> We can use `get()` to test if the specific key exist.
And we can use `put()` to delete the key.

3. Only use the `compareTo()` method to judge the equality of two keys.
> If we mix the `equal()` and the `compareTo()` method to judge the keys' equalities, there will be more unnecessary cost.
> To avoid such cost, we only use the `compareTo()` method.

### 1. APIs

> There shows the APIs of the symbols table. Which we will use in the next node.

#### 1) The key API

> The key API of the table is `put()` and `get()`

```java
/**
* Put the key and value pair into the symbols table.
* @parma key The key you want to insert, when it is null, delete the key from table.
* @parma value The value you want to insert
*/
void put(Key key, Value value)

/**
* Get the value of the specfic key in the table. 
* @parma key The key you specify
* @return The value of the specific key, if the value doesn't exist, return null
*/
Value get(Key key)
```

#### 2) The other method in the ORDERD table

> These are the APIs of the **ordered** table.
> I only display the javadoc of some complex method, there are still some simple ones.

The APIs contians
1. `min()` and `max()`
2. `floor()` and `ceiling()`
3. `rank()` and `select()`
4. `keys()`

> The following are the `rank()`, `select()` and `keys()` method, the others are easy to find their work only though their names.

```java
// Rank & Select
/**
* Get the number of the keys which are less than the specific one. Also called the RANK
* @parma Key key The specific key
* @return The number of keys in the table which are less than the specific one.
*/
int rank(Key key)

/**
* Get the key which is rank k
* @parma int k The rank of the key
* @return The specific key
*/
Key select(int k)

// keys()

/**
* Get the all keys inside the table.
* @return An Iterable Set of keys, such as List or Queue
*/
Iterable<Key> keys()

/**
* Get the set of the range of [lo..hi]
* @parma Key lo The low range of the keys.
* @parma Key hi The high range of the keys.
* @return The Iterable Set of the keys.
*/
Iterable<Key> keys(Key lo, Key hi)
```

## 2) Sequential Search of inorder table

> When we implement the symbol table, we often use **linked list**.
>
> Using this data structure, we can only do the serching with sequential step, by traversal all the node by the single link of the linked list.

### 1. Implementation

```java
public class SequentialSearchST<Key, Value> {
    private Node first;
    
    private class Node {
        // The linked List Node
        Key key;
        Value val;
        Node next;
    }
    
    public Node (Key key, Value val, Node next) {
        this.key = key;
        this.val = val;
        this.next = next;
    }
    
    public Value get(Key key) {
        // get the specific key, return the corrsponding value
        for(Node x = first; x != null; x = x.next) {
            if(key.equals(x.key)) {
                return x.val;   // hit
            }
        }
        return null;    // Not hit
    }
    
    public void put(Key key, Value value) {
        for(Node x = first; x != null; x = x.next) {
            if(key.equals(x.key)) {
                x.val = val;
                return;     // hit
            }    
        }
        // Not hit, create new node
        // Add  at the beginning
        first = new Node(key, val, first);
        
    }
}
```

### 2. Performance

> In a $N$ nodes symbol table, using the sequential serch method, needs $N$ times comparasions in the worst situation.
Especially, **inserting** $N$ distint keys needs $\sim N^2/2$ times comparasions.

### 3. Conclusion

> We could see that the symbol table which is based on the linked list, it has to use the sequential searching method, which truns out to be very low effiency.
> This implementation cannot meet our demand of processing the big data

## 3) Binary Search base on the ordered array

> We are already konw the linked list is low effiency. There are some improment:
> To use the more faster searching method, we use the **array** to implement the symbol talbe.
> Something must keep in mind, that is **this form of symbol table is always ordered**
> Within this data structure, we could use the **BinarySearch** to improve our searching effiency.

### 1. Implementation

> We use two paralle array to store either key or value.
> And we use the `rank()` method to help us find the specific key-value pair

```java
/**
* These method all base on the rank() method
* Which return the number of the keys which are less than the spcific one
* Or the right position of the specific key
*/

public Value get(Key key) {
    if (isEmpty()) return null;
    int i = rank(key);
    if (i< N && keys[i].compareTo(key) == 0) {
        return vals[i];     // hit
    }
    else {
        return null;    // Not hit
    }
}

public void put(Key key, Value value) {
    // The specific position of the key
    int i = rank(key);
    if (i < N && keys[i].compareTo(key) == 0) {
        // Update the value of the existing key
        vals[i] = val; return;
    }
    // Not hit, create new key-value pair 
    for (int j = N; j > i; j--) {
        // MOVE THE DATA FORWARD
        keys[j] = keys[j - 1];
        vals[j] = vals[j - 1];
    }
    keys[i] = key;
    vals[i] = val;
    N++;
}
```

> Special Note for the `rank()` method:
> This method return the number of which keys are less than the specific one.
> And it is the **position** of the specific key
> Improtant: **This method help maintain the order of the symbol table**

```java
/**
* Using the Binary Searching method, due to the ordered talbe.
*/
public int rank(Key key) {
    // Notice that, the lo, hi, mid is the 
    // POSITION of the array
    int lo = 0, hi = N - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;     // Use this format to avoid the overflow
        int cmp = key.compareTo(keys[mid]);
        if (cmp < 0) {
            hi = mid - 1;
        }
        else if(cmp > 0 ) {
            lo = mid + 1;
        }
        else {
            return mid;
        }
    }
    return lo;
}
```

> The binary search is quite simple.
> In a order sequency, you could only compare with the middle data item, to narrow down the range of the possible position
> Important notes:

> 1. Use the `mid = lo + (hi - lo) / 2;` to avoid the overflow.
    >> To understand this, you should understant the lo, hi, mid is only the position of the key, not the value of the key.
    We only need to get the middle **POSITION**, if the amount of the array is extremely large, the `hi + lo` will end up an result of overflow, even do not within the `[lo...hi]`
    To avoid this, or, to ensure the mid will placed in the `range(lo, hi)`, we need to use the `lo` as the beginning, and the step lenth of the half of `[lo...hi]` to let our `mid` reach the destination.
    So, we finally come up with the `mid = lo + (hi - lo) / 2`
    
> 2. Switch to Sequential Searching when the number of the data items is $<5$
>> Actually, there are still a lot of traps in this algorithm, when you have not enough atttention to it.
When the number of the data items is $<5$, the performance of Binary Search and the Sequential Search will be no much different.
So, why not choose the more simple way to implement it?

### 2. Performance

> Using Binary Search in the $N$ keys symbol table, it will need no more than $lgN + 1$ times comparasions.

> But in the situation which needs to insert or delete data item, this search method far from our demand.

> If you want to insert new element into the $N$ elements array, you need $\sim 2N$ times access. And if you want to insert $N$ elements into a empty table, you need $\sim N^2$ times access.

### 3. Conclusion

> The ordered table with the Binary Search method, reduce the time into $lgN$ levels.
For the static table(which do not allow insertion), sort it at the very first place is worth.
But this form still cannot meet our demand of **Fast Search, and Fast Insertion and Deletion**

## 4) The Binary Search Tree

> To solve the problems ofthe , and improve the performance of both **insertion and deletion**,
we use the **Binary Search Tree** to implement.

> Binary Search Tree is a Binary Tree, which:

> 1. Each node has a **Comparable** key
2. Each node is larger than its **left child**, less than its **right child**

> Notice that: The root node is larger than its left subtree, and is less than its right subtree

![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png)


### 1) Implementation

> In this section, there will be the data form, and the specific operations of an ordered symbol table which is base on the Binary Search Tree

> Which are:

> 1. `get()`, `put()`
2. `min()`, `max()`, `floor()`, `ceiling()`
3. `delete()`, `deleteMin()`, `deleteMax()`


#### 1. The Data Implementation

> We use **linked** node to implement this tree, a Node contians:

> 1. The link of the left child
2. The link of the right child
3. Amount of nodes of the tree which use this node as a root
4. The key and the value of the node

<table style="width:25em;">
<th style="text-align:center;" colspan="5">The Node of Binary Search Tree</th>
<tr>
<td style="text-align:center;">Node leftChild</td>
<td style="text-align:center;">Key key</td>
<td style="text-align:center;">Value val</td>
<td style="text-align:center;">int N</td>
<td style="text-align:center;">Node rightChild</td>
</tr>
</table>

Code:

```java
public class BST<Key extend Comparable<Key>, Value> {
    private Node root;
    
    // The inner class of Node
    private class Node {
        private Key key;
        private Value val;
        private Node left, right;
        private int N;
        
        public Node(Key key, Value val, int N) {
            this.key = key;
            this.val = val;
            this.N = N;
        }
    }
    
    public int size() {
        return size(root);
    }
    
    public int size(Node x) {
        if (x == null) {
            return 0;
        }
        else {
            return x.N;
        }
    }
    
    // There are some methods will display at the following
    // Which are:
    // put(), get()
    // max(), min(), floor(), ceiling()
    // delete(), deleteMin(), deleteMax()
    // keys()
}
```

#### 2. Search

> That's the basic idea of the implementation of `put()` and `get()` method
> Using the Binary Search Tree to search data is very simalar to the **Binary Search** method.

> Just start at the root node. Do the comparasion:

> - if the root is equal with the given one, hit
- if the given one is **less than** the root, go to the **left subtree** and keep searching
- or if it is **larger than** the root, go to the **right subtree** and keep searching 
- Finally, if the searching end with a **null node**, and it's not hit.

![Successful Search & Unsuccessful Search](http://algs4.cs.princeton.edu/32bst/images/bst-search.png)

Put & Get:

```java
public Value get(Key key) {
    // Start at the root node
    return get(root, key);
}

private Value get(Node x, Key key) {
    // Find key in the tree which is use the x as the root.
    // If do not hit, return null
    // Notice that, there are some recursively invoke.
    
    if(x == null) {
        return null;
    }
    
    int cmp = key.compareTo(x.key);
    // if do not match, go to the left || right tree to search
    // remenber to return to the uppper level
    // if do not use `return`, the recursive way will borken
    if(cmp < 0) return get(x.left, key);    
    else if(cmp > 0) return get(x.right, key);
    else return x.val;
}

public void put(Key key, Value val) {
    root = put(root, key, val);
}

private Node put(Node x, Key key, Value val) {
    // If node exist, renew it.
    // If not, create it.
    
    // Notice that the put using the recursive way to reach the right position
    // Thus, it must return the link to maintain the structure
    
    if (x == null) return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);
    if (cmp < 0) x.left = put(x.left, key, val);
    else if (cmp > 0) x.right = put (x.right, key, val);
    else x.val = val;
    
    // Renew the N val and return the link to maintian the structure
    x.N = size(x.left) + size(x.right) + 1; // The "1" is the root itself
    return x;   // Return the link to maintain the structure.
    
}
```

#### 3. Insert

> The biggest improvement of Binary Search Tree is the more effient insertion compare to the Binary Search base on array.

> Actually, to do the insertion is pretty simple, just locate the position, and link the new node, that is done.

> Notice that, the Binary Search is ordered, you must locate the position to insert, that is, you cannot insert the node with the position which is not correct.

> The code is at above of `put()` method

![Insertion](http://algs4.cs.princeton.edu/32bst/images/bst-insert.png)

#### 4. Delete

> The delete operation is the most difficult and the most complicated operation in the Binary Search Tree. 
> There are many situation, let dig it step by step.

##### 1) DeleteMin or DeleteMax

> As the most simple method in deletion, we only need to delete the **leaf** node and maintain the connectivity of the tree, if we only need to `deleteMin()` or `deleteMax()`

> We use the `deleteMin()` as a example, do the reversed way, it will become the `deleteMax()`
> 1. Deep into the left subtree, and locate the min node
2. Link its right node with its parent.
3. The garbarge collector will recycle it.

> Notice that, we use the **recursive** method to locate the min node, so it must return the link to maintain the connectivity.

![Delete the min node](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png)

```java
public void deleteMin() {
    root = deleteMin(root);
}

private Node deleteMin(Node x) {
    // Notice that we use the recursive way
    // to deep into the subtree.
    
    // Therefore, it must RETRUEN THE NODE LINK
    // to maintain the connectivity
    
    // Normally, it return itself, 
    // as long as it is not the min one
    
    if (x.left == null) return x.right;
    x.left = deleteMin(x.left);
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

##### 2) The normal delete

> Using the similar way to delete the node which only contians one(or none) child node.
But to delete the node which has the two child, it is more complicated.

> The most important problem is, we need to find a node to **replace the original node**, or the connectivity will be broken.
> To solve it, we use its successor to replace it.
Here are the steps:

1. Save the link as `t`
2. Make `x` point to its successor `min(x.right)`
3. Point `x.right` to `deleteMin(t.right)`
4. Set the `x.right` point to `t.left`
5. Renew the counter

![Normal Delete](http://algs4.cs.princeton.edu/32bst/images/bst-delete.png)

> Notice that, the step 3 is refer to the NO.2 picture.
Point `x.right` to the `deleteMin(t.right)` is doing two things:

> 1. `deleteMin(t.right)` detach $R$ and $H$, and **link** $R$ and $M$
>> That' what the `deleteMin()` actually do, it detach the link between the min item and its parent, and link its parent and its right child

> 2. Point `x.right` to the result of `deleteMin()` is linking the $H$ and $R$
>> Because `deleteMin()` return the link of **itself** eventually, so it will return the link of $R$

> Therefore, we reach the No.3 picture.

Code:

```java
public void delete(Key key) {
    root = delete(root,key);
}
private Node delete(Node x, Key key) {
    // Notice that, we use recursive way
    // to locate the Node which will be delete
    // Also, we need to renew the counter
    
    // Therefore, in this method, we need to 
    // retrun the link of the node itself, to
    // miantain the connectivity
    
    if (x == null) return null;
    int cmp = key.compareTo(key);
    
    // if not hit, 
    // deep into subtree and continue search
    if (cmp < 0) x.left = delete (x.left, key);
    else if (cmp > 0) x.right = delete(x.right, key);
    else {  // hit
        // The deletion of one or none child
        if (x.right == null) return x.left;
        if (x.left == null) return x.right;
        
        // Two child
        Node t = x;
        x = min(t.right);
        // refer to the special notice
        x.right = deleteMin(t.right);
        x.left = t.left;
    }
    // renew counter
    x.N = size(x.left) + size(x.right) + 1;
    
    // return itself to
    // maintain the conectivity
    return x;
}
```

#### 5. Other method of ordering

##### 1) Min & Max

> To find the min or the max item is quite simple, just deep into the left subtree || the right subtree is OK.

```java
public Key min() {
    return min(root).key;
}

private Node min(Node x) {
    if (x.left == null) return x;
    return min(x.left);
}
```

##### 2) Floor & Ceiling

> The `floor()` or the `ceiling()` method is to find a Node that is not less than or not larger than the current one.

> We use the `floor()` method to make an example
> The mian idea is as follow:

> 1. If the given key is less than the root, the floor **must be** in the **left subtree**
2. If the given key is larger than the root, the floor **may be** in the **right subtree**
>> That's if we cannot find it in the right subtree, **the root will be the floor**

```java
public Key floor(Key key) {
    Node x = floor(root, key);
    if (x == null) return null;
    return x.key;
}

private Node floor(Node x, Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp == 0) return x;
    if (cmp < 0) return floor(x.left, key);
    Node t = floor(x.right, key);
    if (t != null) return t;
    else return x;
}
```

##### 3) Select & Rank

> These method is about the **rank** of the specific Node in the tree.
That's why we need to maintain the amount of a subtree, the method follow the following rules:

> 1. If the key is equal to the root, the rank is the amount of the left subtree
2. If the key is less than the root, deep into the left subtree to count
3. If the key is larger than the root, deep into the right subtree, the rank is :
$$Rank = Rank(left\ subtree) + Rank(right\ subtree) + 1$$

```java
public Key select(int k) {
    return select(root, k).key;
}

private Node select(Nodex, int k) {
    if (x == null) return null;
    int t = size(x.left);
    if (t >k) return select(x.left, k);
    else if (t < k) return select(x.right,k - t - 1);
    else return x;
}

public int rank(Key key) {
    return rank(key, root);
}

private int rank(Key key, Node x) {
    if(x == null) return  0;
    int cmp = key.compareTo(x.key);
    if (cmp < 0) return rank(key, x.left);
    else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right);
    else return size(x.left);
}
```

##### 4) Range

> The main idea of the `keys()` method which return the keys of a specific range is :

> We use a **queue** to hold the keys which is within the range.

> 1. If the root is less than the range, go to right subtree.
2. If the root is larger than the range, go to the left subtree.
3. If the root is within the range, enqueue, and **then go to the left and right subtree to search**
>> The most important point is that, if the Node is within the range, its right and left **may still within the range**.
Therefore, whether what the situation we are in, **we all need to traversal the subtree**

```java
public Iterable<Key> keys() {
    return keys(min(), max());
}

public Iterable <Key> keys(Key lo, Key hi) {
    Queue<Key> queue = new Queue<Key>();
    keys(root, queue, lo, hi);
    return queue;
}

private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {
    if (x == null) return;
    int comlo = lo.compareTo(x.key);
    int cmphi = hi.compareTo(x.key);
    
    // Notice that there is no *eles*,
    // that's because we need to traversal the subtree
    if (cmplo < 0) keys(x.left, queue, lo, hi);
    if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key);     // Within range 
    if (cmphi > 0) keys(x.right, queue, lo, hi);
}
```

### 2) Performance

> The Performance of the Binary Search Tree is depend on the $input$.
The best situation is the tree is perfectly balanced, that's the distence between every null link and the root is $\sim lgN$
The worst situation is the input is **originally ordered**, in this case, the tree will become a **linked list**

![Best Case](http://algs4.cs.princeton.edu/32bst/images/bst-best.png) ![Typical Case](http://algs4.cs.princeton.edu/32bst/images/bst-typical.png) ![Worst Case](http://algs4.cs.princeton.edu/32bst/images/bst-worst.png)

> In $N$ random keys Binary Search Tree, the **insertion** and the **not hit search** needs about $\sim 2lnN$ (about $1.39lgN$) times comparasions.

> The worst situation needs $N$ times comparasions.

### 3) Conclusion

> Using the Binary Search Tree is to solve the problem of the inconvience of insertion and deletion when we using the array to search.

> Actually, searching a random key in Binary Search Tree needs $39\%$ more cost, but the cost of insertion has been reduce to the **logarithmic level**, so the extra cost is worth.

> But, the Binary Search Tree still **make no guarantee** of the time complexity, in the worst case, it still need the **liner level** time to search a key.

> Therefore, we come to the following

## 5) The Average Binary Search Tree

### 1. 2-3 Tree

> The 2-3 tree is a null tree, or consist of the following nodes:

> - 2- node, contains **one key** and **two link**, the left child is less, the right child is larger.
- 3- node, contains **two keys** and **three link**, the left is less than both, the right is larger, **the middle is between the parent**.

![2-3 Tree](http://algs4.cs.princeton.edu/33balanced/images/23tree-anatomy.png)

#### 1) Search

> The search is just as the binary search tree, the slightly different is:
when the node is between of the keys which is an 3- node, go to the middle subtree to do the searching.

#### 2) Insertion

> The insertion is quite complex. Let's divide into situations.

##### 1. Insert key in 2-node

> That is the simplest, to insert the key, just change the 2- node into the 3-node, which contain the old and the new one.

![Insert 2-node](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png)

##### 2. Insert key in only 3- node tree

> In this case, we can build a 4-node, temporary, and break it into 3 2-nodes.
This operation increase the height of the tree.

![Insert only 3-node](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png)

##### 3. Insert key into 3-node, which father is 2-node

> That is more complicated, in this situation, we change the 3-node into a temp 4-node, and break it, but we **do not crate new node**, instead of it, we **ship the middle one key to the father**

![Insert 3-node with the 2-node father](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png)

##### 4. Insert key into 3-node, which father is 3-node

> This situation is quite similar to the pervious one, we just create 4-node, and break it, and **do the same thing with it father**, until reach the root
When **reaching the root**, and if the root is 4-node, **break it into the 3 2-nodes**.

![Insert into 3-node with 3-node father and reach root](http://algs4.cs.princeton.edu/33balanced/images/23tree-split.png)

#### 3) Performance

> In a $N$ size 2-3 tree, the search and the insertion access no more $lgN$ nodes.

#### 4) Conclusion

> We have kown the 2-3 tree has a perfect balanced shape, but change the node's type is hard to implement, and we need a structure which we can ship to it by pay the a little cost, obviously the 2-3 tree is not fit for the job.

> Therefore, we come to the implementation of **Red Black Tree**

### 2. Red Black Tree

> Red Black Tree has two types of link, the red one and the black one. 
The black link is the normal link of the binary search tree.
The red link is represent to a 3-node.

![Red Black Tree](http://algs4.cs.princeton.edu/33balanced/images/redblack-encoding.png)

> We give the Red Black Tree some special rules to reduce its difficulty of implementation:

> 1. The red link is always the left link
2. No node is linked by **two red link**
3. The tree is **pefectly black balanced**

> Special Notice:
If the red black tree is fulfil the above rules, **the Red Black Tree will be equivalent to the 2-3 tree**, with this special data structure, we can implement the 2-3 tree with much less code working.
Actually, if we draw the red link as horizontal line, the red black tree is an 2-3 tree

#### 1) Transform

> When do the insertion, we need to do some transforms to make the red black tree to fulfil the rules, just as we need to changge the node type of 2-3 tree, when we do the insertion.

##### 1. Rotation

> When we do the insertion, there will be temporary the **right red link** or the **two continious red link**, in these cases, we need to do the rotation to repair the red black tree.

> By doing the rotation, because we are using the **recursive way**, so that we need to return a link to the parent to maintain the conectivity, and if posiable, continue to repair the parent.

> The main idea of rotation is to **replace the root**

- Rotate Left

![Rotate Left](http://algs4.cs.princeton.edu/33balanced/images/redblack-left-rotate.png)

```java
Node rotateLeft(Node h) {
    Node x = h.right;
    h.right = x.left;   // Link the middle
    x.left = h;         // x ship to the root
    x.color = h.color;  // Change color
    h.color = RED;      // Change color
    x.N = h.N;          // Ship amount
    h.N = 1 + size(h.left) + size(h.right); // Calculate the amount of left subtree
    return x;           // Return a link to parent to maintain the conectivity
}
```

- Rotate Right

> The theory is the same, so that no code for right.
> Sometimes, rotate to right is needed, even though our red black do not allow the right red link

![Rotate Right](http://algs4.cs.princeton.edu/33balanced/images/redblack-right-rotate.png)

##### 2. Filp Color

> When doing the rotation, we often meet this situation, that is,
**The left and right link are both red**

> We are already met this situation in 2-3 tree, that is the **temp 4-node**, when it occurs, we need to break the 4-node, and ship the middle one to the parent, that is exactly what we want to do.

> We use `filpColors()` to deal with the situation
The main idea is:

> 1. **Change the 2 red link into black**
2. **Return a red link to its parent**
 > That is **equal** to the operation **"Break 4-node into 2 2-nodes, ship the middle one to parent"**

![Flip Colors](http://algs4.cs.princeton.edu/33balanced/images/color-flip.png)

```java
void filpColors(Node h) {
    h.color = RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}
```

> Notice that, a red link is represent to a 3-node, so, change the color fo the middle one to $RED$, is equal to ship it to the parent

$\Delta$ Supplement:

> The root node must be always black, so if it eventually change the root's color to $RED$, we need to filp it back to $BLACK$

> That is equal to **break the root, when the root node is a 4-node**, doing such transform, the height of the tree will incease

> Notice that, **only the BLACK link is treat as the normal link**, so **only the edge of the BLACK, in one not hit search will be recognize as height**

#### 2) Insertion

> When doing the insertion in the Red Black Tree, there is a lot of situations, but they all follow the basic rules:

> 1. **The color of the node inserted is $RED$**
2. When the right child is $RED$ and the left child is $BLACK$, **rotate left**
3. When the left child and its left child are both $RED$, **rotate right**
4. When the left child and the right child are both $RED$, **flip colors**

![Situations of Insertion](http://ww2.sinaimg.cn/large/8c1fca6bjw1ez7cbt3il5j21kw23ub29.jpg)

```java
public void put(Key key, Value val) {
    root = put(root, key, val);
    root.color = BLACK;
}

private Node put(Node h, Key key, Value val) {
    if (h == null) {
        return new Node(key, val, 1, RED);
    }
    int cmp = key.compareTo(h.key);
    if (cmp < 0) h.left = put(h.left, key, val);
    else if (cmp > 0) h.right = put(h.right, key, val);
    else h.val = val;
    
    if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);
    if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left) && isRed(h.right)) flipColors(h);
    
    h.N = size(h.left) + size(h.right) + 1;
    return h;
}
```












