## 4. Sort Algorithm

Tags: Algorithm

---


> The cost model
Calculate the number of **compare** and the **exchange**
If do **NOT** need to exchange, we calcute the number of array **ACCESS**

### 1) Selection sort

> 1. Find the smallest item
2. Exchange it with the first item
3. Go to step 1 and exchange it with the second, third, fouth... and so on

- Analysis
> With the $N$ lenth array, it needs about $\frac{N^2}{2}$ times comparation and $N$ times exchanges

    - The needed time does **NOT** connect to the input
    - The movement of data is the least

### 2) Insertion sort

> Increasing order for example

> 1. Compare a[i] with each item in range(a[0], a[N - 1])
2. If the item is **smaller** than `a[i]`, exchange it with `a[i]`

- Implementation

```java
public static void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 0; i < N; i++) {
        for (int j = i; j > 0 && less(a[j], a[j-1]); j--) {
            // Compare a[i] with the items which is at its left side.
            exch(a, j, j-1);
        }
        assert isSorted(a, 0, i);
    }
    assert isSorted(a);
}
```

- Analysis
> This algorithm complexity is base on the input.
If the items are partly ordered, then use this algorithm will be more fast
>
> With the double nested for loop, the worst situation still needs $N^2$ times exchanges

- Improvement
> To optimize, we just simply move the bigger item towards right, rather than exchange the two items.
It can reduce **half** of the accesses of array

```java
/**
* Use this method to replace the exac(), 
* the spare space will be left,
* when the movement was completed,
* just insert the specific item into the room.
*/

a[j] = a[j - 1]
```

### 3) Shell Sort

> Shell Sort is base on the insert sort.
The theory is to make the items **ordered** of **each $h$ interval**
If the $h$ is large, we can move the item much further.

> The gold of Hill sort is gradually reduce the $h$ in order to reach $0$
Just use Insert Sort, just largethen the interval of exchange or movement

- Implementation

```java
public class Shell {
    public static void sort(Comparable[] a) {
        // Increasing order of a[]
        
        int N = a.lenth;
        int h = 1;
        
        while (h < N/3) {   // From N/3 to reduce the h
                            // 1, 4, 13, 40, 121, 364, 1093, ...
            h = 3 * h + 1;
        }
        
        while(h >= 1) {
            // Make the array h ordered
            
            for(int i = h; i < N; i++) {
                // Insert the a[i] into the a[i - h], a[i - 2*h] , a[i - 3*h]
                for(int j = i; j >= h && less(a[j], a[j - h]); j -= h) {    
                    // Replace j-- as the j -= h
                    exch(a, j, j-h)
                }
            }
        }
    }
} 
```

- Improvement

> The Shell Sort is faster than the Insert and the Select,
But, when talk about the analysis, we cannot give a mathmatic comlexity expression, we can only say,

> **The comlexity of Shell Sort will never reach the square level.**

### 4) Merge Sort

> Merge Sort base on the recursive function call
In the after will release the loop version

> The main theory is **Divide and Conquer** strategy
> By Divide the big Set into the small Set and use Insert Sort to sort the small one,
and we merge the small sets to generate the ordered set

> Notice:
**You need to do the comparision during the merge**

#### 1) Implementation

```java
public static void merge(Comparable[] a, int lo, int mid, int hi) {
    // Merge the a[lo...mid] and the a[mid... hi]
    
    int i = lo, j = mid + 1;
    
    // Copy the a[lo...hi] to the assistant array
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k];
    }
    
    // Merge 
    // During the merge, do the comparition
    for (int k = lo; k <= hi; k++) {
        if (i > mid) {                  // When the left side was empty
            a[k] = aux[j++];
        }
        else if (j > hi) {              // When the right side was empty
                                        // Notice that the j is the middle index
                                        // it could also be the lo and gradually reduce
            a[k] = aux[i++];
        }
        else if (less(aux[j], aux[i])) { // Either, compare the left side and the right side
            a[k] = axu[j++];
        }
        else { 
            a[k] = aux[i++];
        }
    }
}
```

#### 2) From Top To Bottom

> This theory is divide the Set and recursive sort and merge.

```java
public static void sort(Comparable[] a) {
    aux = new Comparable[a.lenth];
    sort(a, 0, a.lenth - 1);
}

private static void sort(Comparable[] a, int lo, int hi) {
    if (hi <= lo) return;
    int mid = lo + (hi - lo) / 2;
    
    sort(a, lo, mid);       // Sort the left side
    sort(a, mid + 1, hi);   // Sort the right side
    
    merge(a, lo, mid, hi);  // Merge the result
}
```

- Notice:
> Only the `merge()` method work with the sort, The `sort()` method is to divide and do the recursive `merge()`

- Conclusion
    1. The From Top To Buttom Merge Sort needs ${1 \over 2} NlogN \sim NlogN$
    2. For the $N$ lenth array, from top to buttom merge sort needs $6NlogN$ times array accesses

#### 3) From Buttom To Top

> This theory is to merge the child array pairly, that is, 
first we merge that child array which contains 2 items, and then 4, then 8, $\dots$

- Implementation

```java
public static void sort(Comparable[] a) {
    int N = a.lenth;
    aux = new Comparable[N];
    
    for (int sz = 1; sz < N; sz = sz + sz) {
        for (int lo = 0; lo < N - sz; lo + = sz + sz) {
            merge (a, log, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
        }
    }
}
```

- Notice:
> It use the loop to implemente the algorithm, rather than recursive.

- Conclusion
    1. For the $N$ lenth array, this sort method needs ${1 \over 2} NlogN \sim NlogN$ times comparisions and needs to access the array $6NlogN$ times at **most**.
    2. This method fixs with the **Linked List** organized data, it Only need to reorganize the the linking with sorting it successful. Do NOT need to create the List Node.
        
#### 4) Comparision

> Here are the comparasion of two ways of Merge Sort

1. Two ways have **the same cost**, when the array is $2^N$
> They have the same level of times item comparision, and the same level of times of accessing the arrray.

2. Normally, **the BU way is more efficiently** than the UB way
> Just because the UB way use the implementation of recursive.
It will cost **more memory spece** than the loop version.

3. In some situation, the conclusion might be **opposite**.

#### 5) Outlook

<span style="font-size:20px;">
The Merge sort is the **Progressive optimal** sort algorithm when base on **Comparision**[^footnote5]
</span>

[^footnote5]: That is the Merge Sort Algorithm **Ensure** that even in the worst situation, the least times needed are $NlogN$ level.
And we know that is **NO** algorithm which is base on **Comparision** can ensure the least times comparisions less than $log(N!)$, as we know $\sim NlogN$

### 5) Quick Sort

> Quick Sort is an special Merge Sort algorithm. It bases on the Divided & Conquer theory,
Divide the array into two parts, and individually sort each subarray

> **The partition is extremely important.** 
When the left and right subarray was sorted, the whole array is ordered.

#### 1. Implementation
```java
public class Quick {
    public static void sort (Comparable[] a) {
        // Disable the dependency to the input String
        // It's very important.
        StdRandom.shuffle(a);
        sort(a, 0, a.lenth - 1);
    }
    
    private static void sort (Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int j = partition(a, lo, hi);
        // Sort the left subarray.
        sort(a, lo, j - 1);
        // Sort the right subarray.
        sort(a, j + 1, hi);
    }
}
```

#### 2. The Partition

> The goal of the partition is to find the element,

> - **It's left side is *not large* than it,**
- **It's right side is *not small* than it.**

> Usually, we cannot find such element directly, so we just:

> 1. Choose the element **randomly**
2. Scan the array from left to right and backword at the meanwhile
3. Exchange the element which is at the incorrect position
    >> Exchange the $i$ and $j$ when the a[$i$] is **larger** than $v$ or
    the a[$j$] is **smaller than $v$
> 4. Until the two pointer meet each other, and place the partition element in the position.

![The Partition](http://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png)

##### 1) Implementation

```java
private static int partition(Comparable[] a, int lo, int hi) {
    int i = lo, j = hi + 1;     // The scanner
    Comparable v = a[lo];
    while (true) {
        /**
        * Scan the left and ritht, and exchange
        */
        // Check for the a[i] is less than the v
        while (less(a[++i], v)) {
            if (i == hi) {
                break;
            }
        }
        // Check the a[j] is larger than the v
        while (less(v, a[--j])) {
             if (j == lo) {     // Redundant, because the v is the lo
                break;
             } 
        }
        if (i >= j) {
            break;
        }
        
        // if all were checked, then exchange the a[i] and a[j]
        exch(a, i, j);
    }
    
    // Place the v into the a[j] place
    exch(a, lo, j);
    return j;
}
```

##### 2) Notation

1. Partition occurs in the original space.
    > If we use a assistant array to do the partition, it will be more costly

2. Do not cross the boundary.
3. Maintain the Randomness
4. Beware the endless loop.
    > A normal mistake is not considering the element which is the same.
5. Beware of the recursive
    > If you cannot place the partition element into the right place, it might cause the infinity recursive trap.

#### 3. The Performance

> Quick sort needs $\sim 2NlnN$ times comparations, and $1/6$ exchanges.
In the worst situation, Quick Sort needs $N^2 / 2$ times comparations.
**But the *shuffle* can prevent this situation.**

#### 4. Improvement

##### 1) Switch to the Insertion Sort.

> For the small array, the Insertion Sort is a better way compare with the original Quick Sort.
So, we can switch to the Insertion Sort when the subarray is small.

```java
if (hi <= lo) return;
//Just replace the statement as
if (ho <= lo + M) {
    Insertion.sort(a, lo, hi); 
    return;
}
// Usually the M value is system-related, but within 5 to 15 is considerable.
```

##### 2) 3 sampling Partition

> We can randomly pick up some small samples and calculate their **median** to be the partition element.
Usually the number set to 3 will be the best.


##### 3) 3-Way Partition

> When we recieve an array which contains a lot of repeating elements, using the original Quick Sort seems to be slow.
In this situation, we use the 3-Way Partition.

###### 1. Theory

> Using 3 pointer to maintain the 3 parts: less equal larger

> - Point $lt$ make the a[lo...lt - 1] is less than the $v$
> - Pointer $gt$ make the a[gt + 1... hi] is larger than the $v$
> - Pointer $i$ make the a[lt...i - 1] is equal to the $v$

1. When a[$i$] is less than $v$, exchange a[$lt$] and a[$i$], and plus the $lt$ and $i$.
2. When a[$i$] is larger than $v$, exchange a[$gt$] and a[$i$], and minus the $gt$.
3. When a[$i$] is equal  to the $v$, plus the $v$.[^footnote6]

[^footnote6]: **All the operation will ensure the element of the array is static, and shorthen the value of $gt - 1$**, only in this way the loop is finite.

###### 2. Implementation

```java
public class Quick3way {
    private static void sort(Comparable a, int lo, int hi) {
        if (hi <= lo) return;
        int lt = lo, i = lo + 1, gt = hi;
        Comararble v = a[lo];
        while (i <= gt) {
            int cmp = a[i].compareTo(v);l
            if (cmp < 0) {
                exch(a, lt++, i++);
            }
            else if (cmp >0) {
                exch(a, i, gt--);
            }
            else {
                i++;
            }
        }
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}
```

![3way Quick Sort](http://algs4.cs.princeton.edu/23quicksort/images/partitioning3-overview.png)

###### 3. Performance

> For the array which contains the repeated element, there is a variable to describe it. It calls the **Shannon Information**

$$H = -(p_1lgp_1 + p2lgp_2 + \cdots + p_klgp_k)$$

$H - The \ Shannon\ information$
$p_i - The\ posibillty\ of\ the\ ith\ key\ was\ selected$

> For the array which contains repeated element, there is no algorithm which is base on comparatiion can guarantee it can be within $NH - N$ times comparations complete the sort of the array contains $N$ elements.
In the other way, the up bound of comparation sort for this array is $NH - N$

> For the $N$ array, the 3way Partition needs $\sim 2(ln2)NH$ times comparations.

So it prove that the 3way Partition algorithm is the best of the comparation sort.

### 6) Priority Queue

> Priority Queue is DataStucture which is like a queue,
but support **Delete the Biggest or the Smallest element** and **Insert element**.

> And the most important point is the priority queue can sort the extremely big data, or when your memory was rather small.

#### 1. Implementation

##### 1) Primary

1. Array implementation (Without Order)
> When the order is not important, we could reuse the *Stack* DataStructure. 
The `insert()` method is the same as the `push()` method in the *Stack*.
As the `delMax()` method, we could sort the *Stack* and **Exchange the biggest element and the element at boundary**

2. Array implementation (With Order)
> We can use array to implement it with order.
To maintain the order, we could move the larger element to the right, and the array is always ordered.
We could just use `pop()` method to delete the biggest element.

3. Linked List
> As the *Stack* and the *Queue*, we could just use the **linked list** to implement the priority queue.
Rather ordered or not is the same as the *Array implementation*, just override the `push()` and `pop()` method is okay.

##### 2) Binary Heap Implementation

###### 1. The definition of binary heap

> Binary Heap is a group of elements,
which could be sorted as the **heap ordered** **complete binary tree** 
and stored as the **layer level** in the array.

$\Delta$ Heap Ordered:
> When **all** the nodes of a binary tree is **greater or equal** to its **two subnodes**, it's called **Heap Ordered**.

> So that,
The **root node** is the **biggest** node in the heap ordered binary tree.

For the Prerequisite Knowledge, see the [Binary Tree](#BinaryTree).

###### 2. The implementation of binary heap

> Notice that, the binary heap is just the **complete binary tree**, 
so it's easy to use the **array** to implement it.
Notice that: **WE DO NOT USE a[0]**

For the Prerequisite Knowledge, see the [Complete Binary Tree](#CompleteBinaryTree).

###### 3. Theory

> The main theory is **how to reorder the Heap**,
When we do the comparations and the exchanges, the order of the heap will be destroyed. 
So, we need to reheapifying the heap.

> The main idea is **swim** and **sink**
When a node gain the upper priority (usually when we insert a new node at the bottom fot the heap) , we **swim it**
When a node gain the lower priority (usually when we replace the root node with the low priority one), we **sink it**

1. Swim
> When the node is bigger than its parent, we exchange it with its parent to recover the order of the heap,
KEEP SWIM IT, UNTIL REACH THE BIGGER PARENT

2. Sink
> When the node is less than **both** of its children, we exchange it with the bigger child to recover the order of the heap,
KEEP SINK IT, UNTIL REACH THE **BOTH** LESS CHILD

###### 4. Implementation of methods

1. Insert element
> We insert the new element at the end of **array**,
increase the size of heap, and **swim** the element.

2. Delete the Biggest element
> We **exchange** the **root node** with the node at **the end of the array**,
delete the old root and sink the new root.

```java
public void insert(Key v) {
    pq[++ N] = v;
    swim(N);
}

public Key delMax() {
    Key max = pq[1];
    exch(1, N--);
    pq[N + 1] = null;   // Prevent the object free
    sink(1);
    return max;
}
```

#### 2. Index Priority Queue

> The index priority queue is the priority queue with an index.
With the index, we can deal with the extremely large input data(even cannot be read into memory at one time.) or with the devices with very small memory.

> The main changes is that:
1. We insert the element itself with its index.
2. We delete the max (or the min) element and **return its index**.

##### Example: Multiway Merge

```java
public calss Multiway {
    public static void merge(In[] streams) {
        int N = streams.lenth;    
        // Notice tha the N is the number of the STREAM,
        // not the input strings.
        IndexMinPQ<String> pq = new IndexMinPQ<String> (N);
        
        for (int i = 0; i < N; i++) {
            if (!streams[i].isEmpty) {  // That is a Stream
                // Insert the stream
                pq.insert(i, streams[i].readString());
            }
        }
        
        while (!pq.isEmpty()) {
            // Output the Min element
            StdOut.println(pq.min());
            int i = pq.delMin();
            
            // Keep reading next String
            if (!streams[i].isEmpty() {
                pq.insert(i, streams[i].readString());
            }
        }
        
        public static void main(String[] args) {
            int N = args.lenth;
            In[] streams = new In[N];
            for (int i = 0; i < N; i++) {
                streams[i] = new In(args[i]);
            }
            merge(streams);
        }
    }
}
```

#### 3. Heap Sort

> Heap Sort is the usage of the priority queue.
It insert the element into the priority queue, and invoke the `delMax()` or the `delMin()` method to output the right order.

> This algorithm due to the priority queue, it can deal with the extreameyly huge data, or run at the small memory device.

> It contains two process, **build heap** and **destroy heap**

##### 1) Build Heap
> Notice that: **The array is alread a heap!**
So, we only need to reheapifying it, the buliding process is complete.

##### 2) Destroy Heap (Sort)
> The heap help us to pick up the max or the min element,
So, we only need to pick it out of the heap.
Notice that: How we delete the biggest element?
We delete it by **exchange it with the element which is at the end of the array!**
In fact, we do not need to really *delete* the element, or in another way, free its memory.
We are doing the **SORT**, so, we just **exchange** it (or place it into the right place) is okay.

```java
public static void sort(Comparable[] a) {
    int N = a.lenth;
    
    /**
    * Build the heap
    * We only need to traversal the nodes
    * who contains children.
    * As the heap's theory, we convince that the k = N/2
    */
    for (int k = N/2; k >= 1; k--) {
        sink(a, k, N);
    }
    
    // Destory the heap
    while (N>1) {
        exch(a,1, N--);
        sink(a, 1, N);
    }
}
```

##### 3) Performance

> To sort $N$ elements, the heap sort only need less than $(2NlgN + 2N)$ times comparations and half times exchanges

### 7) Applications

#### 1. Multiple Sort way

> Using the `Comparator` interface, we can use different sort method (or keys) to one kind of data object

#### 2. Comparation of Sort Algorithm

<table>
<tr>
<td rowspan="2" style="text-align:center;vertical-align:middle">Algorithm</td>
<td rowspan="2" style="text-align:center;vertical-align:middle">Stable?</td>
<td rowspan="2" style="text-align:center;vertical-align:middle">Inplace?</td>
<td colspan="2" style="text-align:center;">Grow Rate to Sort N Items</td>
<td rowspan="2" style="text-align:center;vertical-align:middle">Notes</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">Running Time</td>
<td style="width:6em;">Extra Space</td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">Selection Sort</td>
<td style="text-align:center;vertical-align:middle;">No</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">$N^2$</td>
<td style="text-align:center;vertical-align:middle;">1</td>
<td style="text-align:center;vertical-align:middle;"></td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">Insertion Sort</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">Between $N$ and $N^2$</td>
<td style="text-align:center;vertical-align:middle;">1</td>
<td style="text-align:center;vertical-align:middle;">Base on the input</td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">Shell Sort</td>
<td style="text-align:center;vertical-align:middle;">No</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">$N^{6/5}$</td>
<td style="text-align:center;vertical-align:middle;">1</td>
<td style="text-align:center;vertical-align:middle;"></td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">Quick Sort</td>
<td style="text-align:center;vertical-align:middle;">No</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">$NlogN$</td>
<td style="text-align:center;vertical-align:middle;">$lgN$</td>
<td style="text-align:center;vertical-align:middle;">The efficiency is guaranteed by the posibility</td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">3-way Partitioning <br/>Quick Sort</td>
<td style="text-align:center;vertical-align:middle;">No</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">between $N$ and $NlogN$</td>
<td style="text-align:center;vertical-align:middle;">$lgN$</td>
<td style="text-align:center;vertical-align:middle;">The efficiency is guaranteed by the posibility, meanwhile it also depens on the input</td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">Merge Sort</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">No</td>
<td style="text-align:center;vertical-align:middle;">$NlogN$</td>
<td style="text-align:center;vertical-align:middle;">$N$</td>
<td style="text-align:center;vertical-align:middle;"></td>
</tr>

<tr>
<td style="text-align:center;vertical-align:middle;">Heap Sort</td>
<td style="text-align:center;vertical-align:middle;">No</td>
<td style="text-align:center;vertical-align:middle;">Yes</td>
<td style="text-align:center;vertical-align:middle;">$NlogN$</td>
<td style="text-align:center;vertical-align:middle;">$N$</td>
<td style="text-align:center;vertical-align:middle;"></td>
</tr>
</table>

$\Delta$ Conclusions:

1. The Quick Sort is the most fast general Sort Algorithm
> The Quick Sort is at $\sim cNlogN$ level, and the constant $c$ is much less than the other sort algorithm.
Particularly, when using the **3-way Partitioning** some of the situations might be the liner level.
2. When the stability is important, and the space is not so tense, the **Merge Sort** is the best choice.
3. When the space is extremely small, the **Heap Sort** is an good choice.



